/** Conditions Of Use * * This software was developed by employees of the National Institute of* Standards and Technology (NIST), an agency of the Federal Government.* Pursuant to title 15 Untied States Code Section 105, works of NIST* employees are not subject to copyright protection in the United States* and are considered to be in the public domain.  As a result, a formal* license is not needed to use the software.* * This software is provided by NIST as a service and is expressly* provided "AS IS."  NIST MAKES NO WARRANTY OF ANY KIND, EXPRESS, IMPLIED* OR STATUTORY, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT* AND DATA ACCURACY.  NIST does not warrant or make any representations* regarding the use of the software or the results thereof, including but* not limited to the correctness, accuracy, reliability or usefulness of* the software.* * Permission to use this software is contingent upon your acceptance* of the terms of this agreement*  * .* *//******************************************************************************* * Product of NIST/ITL Advanced Networking Technologies Division (ANTD).       * ******************************************************************************/package org.siprop.pip.message.header;import java.lang.reflect.Constructor;import java.util.Collection;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import java.util.ListIterator;import org.siprop.pip.message.util.GenericObject;import org.siprop.pip.message.util.Separators;/** *  * This is the root class for all lists of PIP headers. It imbeds a * PIPObjectList object and extends PIPHeader Lists of ContactPIPObjects etc. * derive from this class. This supports homogeneous lists (all elements in the * list are of the same class). We use this for building type homogeneous lists * of PIPObjects that appear in PIPHeaders *  * @version 1.2 $Revision: 1.5 $ $Date: 2005/10/09 18:47:53 */public class PIPHeaderList extends PIPHeader implements java.util.List {	/**	 * hlist field.	 */	protected List hlist;	private Class myClass;	public String getName() {		return this.headerName;	}	/**	 * Constructor	 * 	 * @param hl	 *            PIPObjectList to set	 * @param hname	 *            String to set	 */	protected PIPHeaderList(List hl, String hname) {		this.headerName = hname;		hlist = hl;	}	/**	 * Constructor	 * 	 * @param hName	 *            String to set	 */	protected PIPHeaderList(String hName) {		this.headerName = hName;		hlist = new LinkedList();	}	/**	 * Constructor	 * 	 * @param objclass	 *            Class to set	 * @param hname	 *            String to set	 */	protected PIPHeaderList(Class objclass, String hname) {		this.headerName = hname;		hlist = new LinkedList();		this.myClass = objclass;	}	/**	 * Concatenate the list of stuff that we are keeping around and also the	 * text corresponding to these structures (that we parsed).	 * 	 * @param objectToAdd	 */	public boolean add(Object objectToAdd) {		hlist.add(objectToAdd);		return true;	}	/**	 * Concatenate the list of stuff that we are keeping around and also the	 * text corresponding to these structures (that we parsed).	 * 	 * @param obj	 *            Genericobject to set	 */	public void addFirst(Object obj) {		hlist.add(0, obj);	}	/**	 * Add to this list.	 * 	 * @param pipheader	 *            PIPHeader to add.	 * @param top	 *            is true if we want to add to the top of the list.	 */	public void add(Object pipheader, boolean top) {		if (top)			this.addFirst(pipheader);		else			this.add(pipheader);	}	/**	 * Concatenate two compatible lists. This appends or prepends the new list	 * to the end of this list.	 * 	 * @param other	 *            PIPHeaderList to set	 * @param topFlag	 *            flag which indicates which end to concatenate	 *            the lists.	 * @throws IllegalArgumentException	 *             if the two lists are not compatible	 */	public void concatenate(PIPHeaderList other, boolean topFlag)			throws IllegalArgumentException {		if (!topFlag) {			this.addAll(other);		} else {			// add given items to the top end of the list.			this.addAll(0, other);		}	}	/**	 * Concatenate two compatible lists. This appends the new list to the end of	 * this list (which is the most common mode for this operation).	 * 	 * @param other	 *            PIPHeaderList	 * @throws IllegalArgumentException	 *             if the two lists are not compatible	 */	public void concatenate(PIPHeaderList other)			throws IllegalArgumentException {		this.concatenate(other, false);	}	/**	 * Encode a list of pip headers. Headers are returned in cannonical form.	 * 	 * @return String encoded string representation of this list of headers.	 *         (Contains string append of each encoded header).	 */	public String encode() {		if (hlist.isEmpty())			return headerName + ":" + Separators.NEWLINE;		StringBuffer encoding = new StringBuffer();			return headerName + Separators.COLON + Separators.SP					+ this.encodeBody() + Separators.NEWLINE;	}	/**	 * Return a list of encoded strings (one for each pipheader).	 * 	 * @return LinkedList containing encoded strings in this header list. an	 *         empty list is returned if this header list contains no pip	 *         headers.	 */	public List getHeadersAsEncodedStrings() {		List retval = new LinkedList();		ListIterator li = hlist.listIterator();		while (li.hasNext()) {			PIPHeader pipheader = (PIPHeader) li.next();			retval.add(pipheader.encode());		}		return retval;	}	/**	 * Get the first element of this list.	 * 	 * @return PIPHeader first element of the list.	 */	public PIPHeader getFirst() {		if (hlist == null || hlist.isEmpty())			return null;		else			return (PIPHeader) hlist.get(0);	}	/**	 * Get the last element of this list.	 * 	 * @return PIPHeader last element of the list.	 */	public PIPHeader getLast() {		if (hlist == null || hlist.isEmpty())			return null;		return (PIPHeader) hlist.get(hlist.size() - 1);	}	/**	 * Get the class for the headers of this list.	 * 	 * @return Class of header supported by this list.	 */	public Class getMyClass() {		return this.myClass;	}	/**	 * Empty check	 * 	 * @return boolean true if list is empty	 */	public boolean isEmpty() {		return hlist.isEmpty();	}	/**	 * Get an initialized iterator for my imbedded list	 * 	 * @return the generated ListIterator	 */	public ListIterator listIterator() {		return hlist.listIterator(0);	}	/**	 * Get the imbedded linked list.	 * 	 * @return the imedded linked list of PIP headers.	 */	public List getHeaderList() {		return this.hlist;	}	/**	 * Get the list iterator for a given position.	 * 	 * @param position	 *            position for the list iterator to return	 * @return the generated list iterator	 */	public ListIterator listIterator(int position) {		return hlist.listIterator(position);	}	/**	 * Remove the first element of this list.	 */	public void removeFirst() {		if (hlist.size() != 0)			hlist.remove(0);	}	/**	 * Remove the last element of this list.	 */	public void removeLast() {		if (hlist.size() != 0)			hlist.remove(hlist.size() - 1);	}	/**	 * Remove a pip header from this list of pip headers.	 * 	 * @param obj	 *            PIPHeader to remove	 * @return boolean	 */	public boolean remove(PIPHeader obj) {		if (hlist.size() == 0)			return false;		else			return hlist.remove(obj);	}	/**	 * Set the root class for all objects inserted into my list (for assertion	 * check)	 * 	 * @param cl	 *            class to set	 */	protected void setMyClass(Class cl) {		this.myClass = cl;	}	/**	 * Array conversion.	 * 	 * @return PIPHeader []	 */	public Object[] toArray() {		return hlist.toArray();	}	/**	 * index of an element.	 * 	 * @return index of the given element (-1) if element does not exist.	 */	public int indexOf(GenericObject gobj) {		return hlist.indexOf(gobj);	}	/**	 * insert at a location.	 * 	 * @param index	 *            location where to add the pipHeader.	 * @param pipHeader	 *            PIPHeader structure to add.	 */	public void add(int index, Object pipHeader)			throws IndexOutOfBoundsException {		hlist.add(index, pipHeader);	}	/**	 * Equality comparison operator.	 * 	 * @param other	 *            the other object to compare with. true is returned iff the	 *            classes match and list of headers herein is equal to the list	 *            of headers in the target (order of the headers is not	 *            important).	 */	public boolean equals(Object other) {		if (other == this)			return true;		if (other instanceof PIPHeaderList) {			PIPHeaderList that = (PIPHeaderList) other;			if (this.hlist == that.hlist)				return true;			else if (this.hlist == null)				return that.hlist == null || that.hlist.size() == 0;			return this.hlist.equals(that.hlist);		}		return false;	}	/**	 * Template match against a template. null field in template indicates wild	 * card match.	 */	public boolean match(PIPHeaderList template) {		if (template == null)			return true;		if (!this.getClass().equals(template.getClass()))			return false;		PIPHeaderList that = (PIPHeaderList) template;		if (this.hlist == that.hlist)			return true;		else if (this.hlist == null)			return false;		else {			for (Iterator it = template.hlist.iterator(); it.hasNext();) {				PIPHeader pipHdr = (PIPHeader) it.next();				boolean found = false;				for (Iterator it1 = this.hlist.iterator(); it1.hasNext()						&& !found;) {					PIPHeader pipHdr1 = (PIPHeader) it1.next();					found = pipHdr1.match(pipHdr);				}				if (!found)					return false;			}			return true;		}	}	/**	 * Merge this with a given template.	 * 	 * @param mergeHdrList	 *            the template to merge with.	 */	public void merge(PIPHeaderList mergeHdrList) {		if (mergeHdrList == null)			return;		Iterator it1 = this.listIterator();		Iterator it2 = mergeHdrList.listIterator();		while (it1.hasNext()) {			GenericObject outerObj = (GenericObject) it1.next();			while (it2.hasNext()) {				Object innerObj = it2.next();				outerObj.merge(innerObj);			}		}	}	/**	 * make a clone of this header list.	 * 	 * @return clone of this Header.	 */	public Object clone() {		try {			Class clazz = this.getClass();			Constructor cons = clazz.getConstructor((Class[])null);			PIPHeaderList retval = (PIPHeaderList) cons.newInstance((Object[])null);			return retval.clonehlist(this.hlist);		} catch (Exception ex) {			throw new RuntimeException("Could not clone!", ex);		}	}	protected final PIPHeaderList clonehlist(List hlistToClone) {		if (hlistToClone != null) {			for (Iterator it = hlistToClone.iterator(); it.hasNext();) {				PIPHeader h = (PIPHeader) it.next();				this.hlist.add(h.clone());			}		}		return this;	}	/**	 * Get the number of headers in the list.	 */	public int size() {		return hlist.size();	}	/**	 * Return true if this is a header list (overrides the base class method	 * which returns false).	 * 	 * @return true	 */	public boolean isHeaderList() {		return true;	}	/**	 * Encode the body of this header (the stuff that follows headerName). A.K.A	 * headerValue. This will not give a reasonable result for WWW-Authenticate,	 * Authorization, Proxy-Authenticate and Proxy-Authorization and hence this	 * is protected.	 */	protected String encodeBody() {		StringBuffer encoding = new StringBuffer();		ListIterator iterator = this.listIterator();		while (true) {			PIPHeader piphdr = (PIPHeader) iterator.next();			if ( piphdr == this ) throw new RuntimeException ("Unexpected circularity in PipHeaderList");			String body = piphdr.encodeBody();			encoding.append(body);			// if (body.equals("")) System.out.println("BODY == ");			if (iterator.hasNext()) {				encoding.append(Separators.COMMA);				continue;			} else				break;		}		return encoding.toString();	}	/**	 * Add a collection of headers.	 * 	 * @param collection --	 *            a collection containing the headers to add.	 * 	 */	public boolean addAll(Collection collection) {		return this.hlist.addAll(collection);	}	/**	 * Add all the elements of this collection.	 */	public boolean addAll(int index, Collection collection) {		return this.hlist.addAll(index, collection);	}	public void clear() {		this.hlist.clear();	}	public boolean contains(Object header) {		return this.hlist.contains(header);	}	/**	 * Check if the list contains all the headers in this collection.	 * 	 * @param collection --	 *            the collection of headers to test against.	 */	public boolean containsAll(Collection collection) {		return this.hlist.containsAll(collection);	}	/**	 * Get the object at the specified location.	 * 	 * @param index --	 *            location from which to get the object.	 * 	 */	public Object get(int index) {		return this.hlist.get(index);	}	/**	 * Return the index of a given object.	 * 	 * @param obj --	 *            object whose index to compute.	 */	public int indexOf(Object obj) {		return this.hlist.indexOf(obj);	}	/**	 * Return the iterator to the imbedded list.	 * 	 * @return iterator to the imbedded list.	 * 	 */	public java.util.Iterator iterator() {		return this.hlist.listIterator();	}	/**	 * Get the last index of the given object.	 * 	 * @param obj --	 *            object whose index to find.	 */	public int lastIndexOf(Object obj) {		return this.hlist.lastIndexOf(obj);	}	/**	 * Remove the given object.	 * 	 * @param obj --	 *            object to remove.	 * 	 */	public boolean remove(Object obj) {		return this.hlist.remove(obj);	}	/**	 * Remove the object at a given index.	 * 	 * @param index --	 *            index at which to remove the object	 */	public Object remove(int index) {		return this.hlist.remove(index);	}	/**	 * Remove all the elements.	 * @see List#removeAll(java.util.Collection)	 */	public boolean removeAll(java.util.Collection collection) {		return this.hlist.removeAll(collection);	}		/**	 * @see List#retainAll(java.util.Collection)	 * @param collection	 */	public boolean retainAll(java.util.Collection collection) {		return this.hlist.retainAll(collection);	}	/**	 * Get a sublist of the list.	 * 	 * @see List#subList(int, int)	 */	public java.util.List subList(int index1, int index2) {		return this.hlist.subList(index1, index2);	}	/**	 * @see Object#hashCode()	 * @return -- the computed hashcode.	 */	public int hashCode() {		return this.headerName.hashCode();	}	/**	 * Set a PIPHeader at a particular position in the list.	 * 	 * @see List#set(int, java.lang.Object)	 */	public Object set(int position, Object pipHdr) {		return hlist.set(position, pipHdr);	}		/**	 * Convert a list of headers to an array.	 * 	 * @see List#toArray(java.lang.Object[])	 */	public Object[] toArray(Object[] array) {		return hlist.toArray(array);	}}