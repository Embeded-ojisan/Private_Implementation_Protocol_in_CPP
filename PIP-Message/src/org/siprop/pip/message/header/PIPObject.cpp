/** Conditions Of Use * * This software was developed by employees of the National Institute of* Standards and Technology (NIST), an agency of the Federal Government.* Pursuant to title 15 Untied States Code Section 105, works of NIST* employees are not subject to copyright protection in the United States* and are considered to be in the public domain.  As a result, a formal* license is not needed to use the software.* * This software is provided by NIST as a service and is expressly* provided "AS IS."  NIST MAKES NO WARRANTY OF ANY KIND, EXPRESS, IMPLIED* OR STATUTORY, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT* AND DATA ACCURACY.  NIST does not warrant or make any representations* regarding the use of the software or the results thereof, including but* not limited to the correctness, accuracy, reliability or usefulness of* the software.* * Permission to use this software is contingent upon your acceptance* of the terms of this agreement*  * .* *//***************************************************************************** * Product of NIST/ITL Advanced Networking Technologies Division (ANTD).     * *****************************************************************************/package org.siprop.pip.message.header;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import org.siprop.pip.message.util.GenericObject;import org.siprop.pip.message.util.GenericObjectList;import org.siprop.pip.message.util.InternalErrorHandler;/** * Root class for all singleton objects in this package: * specializes the sip.header.GenericObject class for PIPHeader * related objects. * * @version 1.2 $Revision: 1.8 $ $Date: 2007/01/08 19:24:57 $ * * @author M. Ranganathan   <br/> * * * */public abstract class PIPObject extends GenericObject {	/** default Constructor	 */	protected PIPObject() {		super();	}	/** Encode the header into a String.	 * @return String	 */	public abstract String encode();	/**	 * An introspection based equality predicate for PIPObjects.	 *@param other the other object to test against.	 */	public boolean equals(Object other) {		if (!this.getClass().equals(other.getClass()))			return false;		PIPObject that = (PIPObject) other;		Class myclass = this.getClass();		Class hisclass = other.getClass();		while (true) {			Field[] fields = myclass.getDeclaredFields();			if (!hisclass.equals(myclass))				return false;			Field[] hisfields = hisclass.getDeclaredFields();			for (int i = 0; i < fields.length; i++) {				Field f = fields[i];				Field g = hisfields[i];				// Only print protected and public members.				int modifier = f.getModifiers();				if ((modifier & Modifier.PRIVATE) == Modifier.PRIVATE)					continue;				Class fieldType = f.getType();				String fieldName = f.getName();				if (fieldName.compareTo("stringRepresentation") == 0) {					continue;				}				if (fieldName.compareTo("indentation") == 0) {					continue;				}				try {					// Primitive fields are printed with type: value					if (fieldType.isPrimitive()) {						String fname = fieldType.toString();						if (fname.compareTo("int") == 0) {							if (f.getInt(this) != g.getInt(that))								return false;						} else if (fname.compareTo("short") == 0) {							if (f.getShort(this) != g.getShort(that))								return false;						} else if (fname.compareTo("char") == 0) {							if (f.getChar(this) != g.getChar(that))								return false;						} else if (fname.compareTo("long") == 0) {							if (f.getLong(this) != g.getLong(that))								return false;						} else if (fname.compareTo("boolean") == 0) {							if (f.getBoolean(this) != g.getBoolean(that))								return false;						} else if (fname.compareTo("double") == 0) {							if (f.getDouble(this) != g.getDouble(that))								return false;						} else if (fname.compareTo("float") == 0) {							if (f.getFloat(this) != g.getFloat(that))								return false;						}					} else if (g.get(that) == f.get(this))						continue;					else if (f.get(this) == null && g.get(that) != null)						return false;					else if (g.get(that) == null && f.get(this) != null)						return false;					else if (!f.get(this).equals(g.get(that)))						return false;				} catch (IllegalAccessException ex1) {					System.out.println("accessed field " + fieldName);					System.out.println("modifier  " + modifier);					System.out.println("modifier.private  " + Modifier.PRIVATE);					InternalErrorHandler.handleException(ex1);				}			}			if (myclass.equals(PIPObject.class))				break;			else {				myclass = myclass.getSuperclass();				hisclass = hisclass.getSuperclass();			}		}		return true;	}	/** An introspection based predicate matching using a template	 * object. Allows for partial match of two protocl Objects.	 * You can set a generalized matcher (using regular expressions	 * for example) by implementing the Match interface and registering	 * it with the template.	 *@param other the match pattern to test against. The match object	 * has to be of the same type (class). Primitive types	 * and non-sip fields that are non null are matched for equality.	 * Null in any field  matches anything. Some book-keeping fields	 * are ignored when making the comparison.	 *	 */	public boolean match(Object other) {		if (other == null) {			return true;		}				if (!this.getClass().equals(other.getClass()))			return false;		GenericObject that = (GenericObject) other;		Class myclass = this.getClass();		Class hisclass = other.getClass();		while (true) {			Field[] fields = myclass.getDeclaredFields();			Field[] hisfields = hisclass.getDeclaredFields();			for (int i = 0; i < fields.length; i++) {				Field f = fields[i];				Field g = hisfields[i];				// Only print protected and public members.				int modifier = f.getModifiers();				if ((modifier & Modifier.PRIVATE) == Modifier.PRIVATE)					continue;				Class fieldType = f.getType();				String fieldName = f.getName();				if (fieldName.compareTo("stringRepresentation") == 0) {					continue;				}				if (fieldName.compareTo("indentation") == 0) {					continue;				}				try {					if (fieldType.isPrimitive()) {						String fname = fieldType.toString();						if (fname.compareTo("int") == 0) {							if (f.getInt(this) != g.getInt(that))								return false;						} else if (fname.compareTo("short") == 0) {							if (f.getShort(this) != g.getShort(that))								return false;						} else if (fname.compareTo("char") == 0) {							if (f.getChar(this) != g.getChar(that))								return false;						} else if (fname.compareTo("long") == 0) {							if (f.getLong(this) != g.getLong(that))								return false;						} else if (fname.compareTo("boolean") == 0) {							if (f.getBoolean(this) != g.getBoolean(that))								return false;						} else if (fname.compareTo("double") == 0) {							if (f.getDouble(this) != g.getDouble(that))								return false;						} else if (fname.compareTo("float") == 0) {							if (f.getFloat(this) != g.getFloat(that))								return false;						} else {							InternalErrorHandler.handleException(								"unknown type");						}					} else {						Object myObj = f.get(this);						Object hisObj = g.get(that);						if (hisObj != null && myObj == null)							return false;						else if (hisObj == null && myObj != null)							continue;						else if (hisObj == null && myObj == null)							continue;						else if (							hisObj instanceof java.lang.String								&& myObj instanceof java.lang.String) {							if ((((String) hisObj).trim()).equals(""))								continue;							if (((String) myObj)								.compareToIgnoreCase((String) hisObj)								!= 0)								return false;						} else if (							hisObj != null								&& GenericObject.isMySubclass(myObj.getClass())								&& GenericObject.isMySubclass(hisObj.getClass())								&& myObj.getClass().equals(hisObj.getClass())								&& ((GenericObject) hisObj).getMatcher()									!= null) {							String myObjEncoded =								((GenericObject) myObj).encode();							boolean retval =								((GenericObject) hisObj).getMatcher().match(									myObjEncoded);							if (!retval)								return false;						} else if (							GenericObject.isMySubclass(myObj.getClass())								&& !((GenericObject) myObj).match(hisObj))							return false;						else if (							GenericObjectList.isMySubclass(myObj.getClass())								&& !((GenericObjectList) myObj).match(hisObj))							return false;					}				} catch (IllegalAccessException ex1) {					InternalErrorHandler.handleException(ex1);				}			}			if (myclass.equals(PIPObject.class))				break;			else {				myclass = myclass.getSuperclass();				hisclass = hisclass.getSuperclass();			}		}		return true;	}	public String toString() {		return this.encode();	}}