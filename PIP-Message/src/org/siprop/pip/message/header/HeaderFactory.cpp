/** Conditions Of Use * * This software was developed by employees of the National Institute of* Standards and Technology (NIST), an agency of the Federal Government.* Pursuant to title 15 Untied States Code Section 105, works of NIST* employees are not subject to copyright protection in the United States* and are considered to be in the public domain.  As a result, a formal* license is not needed to use the software.* * This software is provided by NIST as a service and is expressly* provided "AS IS."  NIST MAKES NO WARRANTY OF ANY KIND, EXPRESS, IMPLIED* OR STATUTORY, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT* AND DATA ACCURACY.  NIST does not warrant or make any representations* regarding the use of the software or the results thereof, including but* not limited to the correctness, accuracy, reliability or usefulness of* the software.* * Permission to use this software is contingent upon your acceptance* of the terms of this agreement.* *//******************************************************************************** Product of NIST/ITL Advanced Networking Technologies Division (ANTD).        ********************************************************************************/package org.siprop.pip.message.header;import java.text.ParseException;import org.siprop.pip.message.address.Address;import org.siprop.pip.message.parser.StringMsgParser;import org.siprop.pip.message.util.InvalidArgumentException;/** This file contains enhancements contributed by Alexandre Silva Santos * (PT-Inovacao) and Miguel Freitas *//** Implementation of the JAIN PIP  HeaderFactory* * @version 1.2 $Revision: 1.11 $ $Date: 2007/01/08 19:24:56 $* @since 1.1**@author M. Ranganathan   <br/>*@author Olivier Deruelle <br/>***/public class HeaderFactory {	/**	  * Creates a new AllowHeader based on the newly supplied method value.	  *	  * @param method - the new string containing the method value.	  * @throws ParseException which signals that an error has been reached	  * unexpectedly while parsing the method value.	  * @return the newly created AllowHeader object.	  */	public AllowHeader createAllowHeader(String method) throws ParseException {		if (method == null)			throw new NullPointerException("null arg method");		AllowHeader allow = new AllowHeader();		allow.setMethod(method);		return allow;	}	/**	 * Creates a new CSeqHeader based on the newly supplied sequence number and 	 * method values.	 *	 * @param sequenceNumber - the new integer value of the sequence number.	 * @param method - the new string value of the method.	 * @throws InvalidArgumentException if supplied sequence number is less 	 * than zero.	 * @throws ParseException which signals that an error has been reached	 * unexpectedly while parsing the method value.	 * @return the newly created CSeqHeader object.	 */	public CSeqHeader createCSeqHeader( long sequenceNumber, String method)		throws ParseException, InvalidArgumentException {		if (sequenceNumber < 0)			throw new InvalidArgumentException("bad arg " + sequenceNumber);		if (method == null)			throw new NullPointerException("null arg method");		CSeqHeader cseq = new CSeqHeader();		cseq.setMethod(method);		cseq.setSeqNumber(sequenceNumber);		return cseq;	}	/**	 * Creates a new CallIdHeader based on the newly supplied callId value. 	 * 	 * @param callId - the new string value of the call-id.	 * @throws ParseException which signals that an error has been reached	 * unexpectedly while parsing the callId value.	 * @return the newly created CallIdHeader object.	 */	public CallIdHeader createCallIdHeader(String callId)		throws ParseException {		if (callId == null)			throw new NullPointerException("null arg callId");		CallIdHeader c = new CallIdHeader();		c.setCallId(callId);		return c;	}	/**	 * Creates a new ContactHeader based on the newly supplied address value.	 *	 * @param address - the new Address value of the address.	 * @return the newly created ContactHeader object.	 */	public ContactHeader createContactHeader(Address address) {		if (address == null)			throw new NullPointerException("null arg address");		ContactHeader contact = new ContactHeader();		contact.setAddress(address);		return contact;	}	/**	* Creates a new wildcard ContactHeader. This is used in Register requests	* to indicate to the server that it should remove all locations the	* at which the user is currently available. This implies that the 	* following conditions are met:	* <ul>	* <li><code>ContactHeader.getAddress.getAddress.getUserInfo() == *;</code>	* <li><code>ContactHeader.getAddress.getAddress.isWildCard() == true;</code>	* <li><code>ContactHeader.getExpires() == 0;</code>	* </ul>	*	* @return the newly created wildcard ContactHeader.	*/	public ContactHeader createContactHeader() {		ContactHeader contact = new ContactHeader();		contact.setWildCardFlag(true);		contact.setExpires(0);		return contact;	}	/**	 * Creates a new CSeqHeader based on the newly supplied contentLength value.	 *	 * @param contentLength - the new integer value of the contentLength.	 * @throws InvalidArgumentException if supplied contentLength is less 	 * than zero.	 * @return the newly created ContentLengthHeader object.	 */	public ContentLengthHeader createContentLengthHeader(int contentLength)		throws InvalidArgumentException {		if (contentLength < 0)			throw new InvalidArgumentException("bad contentLength");		ContentLengthHeader c = new ContentLengthHeader();		c.setContentLength(contentLength);		return c;	}	/**	 * Creates a new ContentTypeHeader based on the newly supplied contentType and 	 * contentSubType values.	 *	 * @param contentType - the new string content type value.	 * @param contentSubType - the new string content sub-type value.	 * @throws ParseException which signals that an error has been reached	 * unexpectedly while parsing the content type or content subtype value.	 * @return the newly created ContentTypeHeader object.	 */	public ContentTypeHeader createContentTypeHeader(		String contentType,		String contentSubType)		throws ParseException {		if (contentType == null || contentSubType == null)			throw new NullPointerException("null contentType or subType");		ContentTypeHeader c = new ContentTypeHeader();		c.setContentType(contentType);		c.setContentSubType(contentSubType);		return c;	}	/**	 * Creates a new FromHeader based on the newly supplied address.	 *	 * @param address - the new Address object of the address.	 * @throws ParseException which signals that an error has been reached	 * unexpectedly while parsing the tag value.	 * @return the newly created FromHeader object.  	 */	public FromHeader createFromHeader(Address address)		throws ParseException {		if (address == null)			throw new NullPointerException("null address arg");		FromHeader from = new FromHeader();		from.setAddress(address);		return from;	}	/**	 * Creates a new ToHeader based on the newly supplied address. 	 *	 * @param address - the new Address object of the address.	 * @throws ParseException which signals that an error has been reached	 * unexpectedly while parsing the tag value.	 * @return the newly created ToHeader object.  	 */	public ToHeader createToHeader(Address address)		throws ParseException {		if (address == null)			throw new NullPointerException("null address");		ToHeader to = new ToHeader();		to.setAddress(address);		return to;	}	/** Create and parse a header.	 *	 * @param headerName -- header name for the header to parse.	 * @param headerValue -- header value for the header to parse.	 * @throws ParseException	 * @return  the parsed pip header	 */	public PIPHeader createHeader(		String headerName,		String headerValue)		throws java.text.ParseException {		if (headerName == null)			throw new NullPointerException("header name is null");		String hdrText =			new StringBuffer()				.append(headerName)				.append(":")				.append(headerValue)				.toString();		StringMsgParser smp = new StringMsgParser();		PIPHeader pipHeader = smp.parsePIPHeader(hdrText);		if (pipHeader instanceof PIPHeaderList) {			if (((PIPHeaderList) pipHeader).size() > 1) {				throw new ParseException(					"Only singleton allowed " + hdrText,					0);			} else if (((PIPHeaderList) pipHeader).size() == 0) {				try {					return (PIPHeader) ((PIPHeaderList) pipHeader)						.getMyClass()						.newInstance();				} catch (InstantiationException ex) {					ex.printStackTrace();					return null;				} catch (IllegalAccessException ex) {					ex.printStackTrace();					return null;				}			} else {				return (PIPHeader) ((PIPHeaderList) pipHeader).getFirst();			}		} else {			return (PIPHeader) pipHeader;		}	}	/** Create and return a list of headers.	 *@param headers -- list of headers.	 *@throws ParseException -- if a parse exception occurs or a List	 * of that type of header is not alowed.	 *@return a List containing the headers.	 */	public java.util.List createHeaders(String headers)		throws java.text.ParseException {		if (headers == null)			throw new NullPointerException("null arg!");		StringMsgParser smp = new StringMsgParser();		PIPHeader shdr = smp.parsePIPHeader(headers);		if (shdr instanceof PIPHeaderList)			return (PIPHeaderList) shdr;		else			throw new ParseException(				"List of headers of this type is not allowed in a message",				0);	}        	       //////////////////////////////////////////////////////////    // Constructor    //////////////////////////////////////////////////////////    /**	 * Default constructor.	 */	public HeaderFactory() {	}		}