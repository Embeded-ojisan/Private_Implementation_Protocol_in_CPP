/** Conditions Of Use * * This software was developed by employees of the National Institute of* Standards and Technology (NIST), an agency of the Federal Government.* Pursuant to title 15 Untied States Code Section 105, works of NIST* employees are not subject to copyright protection in the United States* and are considered to be in the public domain.  As a result, a formal* license is not needed to use the software.* * This software is provided by NIST as a service and is expressly* provided "AS IS."  NIST MAKES NO WARRANTY OF ANY KIND, EXPRESS, IMPLIED* OR STATUTORY, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT* AND DATA ACCURACY.  NIST does not warrant or make any representations* regarding the use of the software or the results thereof, including but* not limited to the correctness, accuracy, reliability or usefulness of* the software.* * Permission to use this software is contingent upon your acceptance* of the terms of this agreement*  * .* *//******************************************************************************* * Product of NIST/ITL Advanced Networking Technologies Division (ANTD)         * *******************************************************************************/package org.siprop.pip.message;import java.io.UnsupportedEncodingException;import java.text.ParseException;import java.util.Hashtable;import java.util.Iterator;import java.util.LinkedList;import org.siprop.pip.message.address.PipUri;import org.siprop.pip.message.address.URI;import org.siprop.pip.message.header.CSeqHeader;import org.siprop.pip.message.header.CallIdHeader;import org.siprop.pip.message.header.ContactList;import org.siprop.pip.message.header.ContentLengthHeader;import org.siprop.pip.message.header.ContentTypeHeader;import org.siprop.pip.message.header.FromHeader;import org.siprop.pip.message.header.PIPHeader;import org.siprop.pip.message.header.RequestLine;import org.siprop.pip.message.header.ToHeader;import org.siprop.pip.message.util.InternalErrorHandler;import org.siprop.pip.message.util.InvalidArgumentException;import org.siprop.pip.message.util.PIPDuplicateHeaderException;/* * Acknowledgements: Mark Bednarek made a few fixes to this code. Jeff Keyser * added two methods that create responses and generate cancel requests from * incoming orignial requests without the additional overhead of encoding and * decoding messages. Bruno Konik noticed an extraneous newline added to the end * of the buffer when encoding it. Incorporates a bug report from Andreas * Bystrï¿½m. Szabo Barna noticed a contact in a cancel request - this is a * pointless header for cancel. Antonis Kyardis contributed bug fixes. * Jeroen van Bemmel noted that method names are case sensitive, should use equals()  * in getting CannonicalName  *  *//** * The PIP Request structure. *  * @version 1.2 $Revision: 1.24 $ $Date: 2006/12/22 02:23:32 $ * @since 1.1 *  * @author M. Ranganathan  <br/> *  *  *  */public final class PIPRequest extends PIPMessage {	private static final String DEFAULT_USER = "ip";	private static final String DEFAULT_TRANSPORT = "tcp";	protected RequestLine requestLine;	private Object messageChannel;	    public static final String INVITE = "INVITE";        public static final String ACK = "ACK";    public static final String BYE = "BYE";    public static final String CANCEL = "CANCEL";		/**	 * A table that maps a name string to its cannonical constant.	 * This is used to speed up parsing of messages .equals reduces	 * to == if we use the constant value.	 */	private static final Hashtable nameTable = new Hashtable();		private static void putName(String name) {		nameTable.put(name, name);	}	static {		putName(PIPRequest.INVITE);		putName(PIPRequest.BYE);		putName(PIPRequest.CANCEL);		putName(PIPRequest.ACK);	}	/**	 * Set to standard constants to speed up processing. this makes equals	 * comparisons run much faster in the stack because then it is just identity	 * comparision. Character by char comparison is not required.	 * The method returns the String CONSTANT corresponding to the	 * String name.	 * 	 */	public static String getCannonicalName(String method) {			if (nameTable.containsKey(method))			return (String) nameTable.get(method);		else			return method;	}	/**	 * Get the Request Line of the PIPRequest.	 * 	 * @return the request line of the PIP Request.	 */	public RequestLine getRequestLine() {		return requestLine;	}	/**	 * Set the request line of the PIP Request.	 * 	 * @param requestLine	 *            is the request line to set in the PIP Request.	 */	public void setRequestLine(RequestLine requestLine) {		this.requestLine = requestLine;	}	/**	 * Constructor.	 */	public PIPRequest() {		super();	}	/**	 * Check header for constraints. (1) Invite options and bye requests can	 * only have PIP URIs in the contact headers. (2) Request must have cseq, to	 * and from and via headers. (3) Method in request URIold must match that in	 * CSEQ.	 */	public void checkHeaders() throws ParseException {		String prefix = "Missing a required header : ";		/* Check for required headers */		if (getCSeq() == null) {			throw new ParseException(prefix + CSeqHeader.NAME, 0);		}		if (getTo() == null) {			throw new ParseException(prefix + ToHeader.NAME, 0);		}				if ( this.callIdHeader == null || this.callIdHeader.getCallId() == null || 				callIdHeader.getCallId().equals("")) {			throw new ParseException(prefix + CallIdHeader.NAME,0);		}		if (getFrom() == null) {			throw new ParseException(prefix + FromHeader.NAME, 0);		}				/*		 * ContactHeader header is mandatory for a PIP INVITE request.		 */		if ( this.getContactHeader() == null ) {			throw new ParseException("ContactHeader Header is Mandatory for a PIP INVITE", 0);		}		if (requestLine != null				&& requestLine.getMethod() != null				&& getCSeq().getMethod() != null				&& requestLine.getMethod().compareTo(getCSeq().getMethod()) != 0) {			throw new ParseException(					"CSEQ method mismatch with  Request-Line ", 0);		}				/*		 * Check Offer/Answer.		 */		try {			if (PIPRequest.INVITE.equals(this.getMethod()) && this.getMessageContent() == null) {				throw new ParseException(						"Offer/Answer null ", 0);			}		} catch (UnsupportedEncodingException e) {			throw new ParseException(					"Offer/Answer null ", 0);		}	}	/**	 * Set the default values in the request URIold if necessary.	 */	protected void setDefaults() {		// The request line may be unparseable (set to null by the		// exception handler.		if (requestLine == null)			return;		String method = requestLine.getMethod();		// The requestLine may be malformed!		if (method == null)			return;		URI u = requestLine.getUri();		if (u == null)			return;		if (method.compareTo(PIPRequest.INVITE) == 0) {			if (u instanceof PipUri) {				PipUri pipUri = (PipUri) u;				pipUri.setUserParam(DEFAULT_USER);				try {					pipUri.setTransportParam(DEFAULT_TRANSPORT);				} catch (ParseException ex) {				}			}		}	}	/**	 * Patch up the request line as necessary.	 */	protected void setRequestLineDefaults() {		String method = requestLine.getMethod();		if (method == null) {			CSeqHeader cseq = (CSeqHeader) this.getCSeq();			if (cseq != null) {				method = getCannonicalName(cseq.getMethod());				requestLine.setMethod(method);			}		}	}	/**	 * A conveniance function to access the Request URIold.	 * 	 * @return the requestURI if it exists.	 */	public URI getRequestURI() {		if (this.requestLine == null)			return null;		else			return (URI) this.requestLine.getUri();	}	/**	 * Sets the RequestURI of Request. The Request-URIold is a PIP or PIPS URIold or a	 * general URIold. It indicates the user or service to which this request is	 * being addressed. PIP elements MAY support Request-URIs with schemes other	 * than "pip" and "pips", for example the "tel" URIold scheme. PIP elements MAY	 * translate non-PIP URIs using any mechanism at their disposal, resulting	 * in PIP URIold, PIPS URIold, or some other scheme.	 * 	 * @param uri	 *            the new Request URIold of this request message	 */	public void setRequestURI(URI uri) {		if (this.requestLine == null) {			this.requestLine = new RequestLine();		}		this.requestLine.setUri((URI) uri);	}	/**	 * Set the method.	 * 	 * @param method	 *            is the method to set.	 * @throws IllegalArgumentException	 *             if the method is null	 */	public void setMethod(String method) {		if (method == null)			throw new IllegalArgumentException("null method");		if (this.requestLine == null) {			this.requestLine = new RequestLine();		}		// Set to standard constants to speed up processing.		// this makes equals compares run much faster in the		// stack because then it is just identity comparision		String meth = getCannonicalName(method);		this.requestLine.setMethod(meth);		if (this.cSeqHeader != null) {			try {				this.cSeqHeader.setMethod(meth);			} catch (ParseException e) {			}		}	}	/**	 * Get the method from the request line.	 * 	 * @return the method from the request line if the method exits and null if	 *         the request line or the method does not exist.	 */	public String getMethod() {		if (requestLine == null)			return null;		else			return requestLine.getMethod();	}	/**	 * Encode the PIP Request as a string.	 * 	 * @return an encoded String containing the encoded PIP Message.	 */	public String encode() {		String retval;		if (requestLine != null) {			this.setRequestLineDefaults();			retval = requestLine.encode() + super.encode();		} else			retval = super.encode();		return retval;	}	/**	 * Encode only the headers and not the content.	 */	public String encodeMessage() {		String retval;		if (requestLine != null) {			this.setRequestLineDefaults();			retval = requestLine.encode() + super.encodePIPHeaders();		} else			retval = super.encodePIPHeaders();		return retval;	}	/**	 * ALias for encode above.	 */	public String toString() {		return this.encode();	}	/**	 * Make a clone (deep copy) of this object. You can use this if you want to	 * modify a request while preserving the original	 * 	 * @return a deep copy of this object.	 */	public Object clone() {		PIPRequest retval = (PIPRequest) super.clone();		// Do not copy over the tx pointer -- this is only for internal		// tracking.		if (this.requestLine != null)			retval.requestLine = (RequestLine) this.requestLine.clone();		return retval;	}	/**	 * Compare for equality.	 * 	 * @param other	 *            object to compare ourselves with.	 */	public boolean equals(Object other) {		if (!this.getClass().equals(other.getClass()))			return false;		PIPRequest that = (PIPRequest) other;		return requestLine.equals(that.requestLine) && super.equals(other);	}	/**	 * Get the message as a linked list of strings. Use this if you want to	 * iterate through the message.	 * 	 * @return a linked list containing the request line and headers encoded as	 *         strings.	 */	public LinkedList getMessageAsEncodedStrings() {		LinkedList retval = super.getMessageAsEncodedStrings();		if (requestLine != null) {			this.setRequestLineDefaults();			retval.addFirst(requestLine.encode());		}		return retval;	}	/**	 * Match with a template. You can use this if you want to match incoming	 * messages with a pattern and do something when you find a match. This is	 * useful for building filters/pattern matching responders etc.	 * 	 * @param matchObj	 *            object to match ourselves with (null matches wildcard)	 * 	 */	public boolean match(Object matchObj) {		if (matchObj == null)			return true;		else if (!matchObj.getClass().equals(this.getClass()))			return false;		else if (matchObj == this)			return true;		PIPRequest that = (PIPRequest) matchObj;		RequestLine rline = that.requestLine;		if (this.requestLine == null && rline != null)			return false;		else if (this.requestLine == rline)			return super.match(matchObj);		return requestLine.match(that.requestLine) && super.match(matchObj);	}	/**	 * Encode this into a byte array. This is used when the body has been set as	 * a binary array and you want to encode the body as a byte array for	 * transmission.	 * 	 * @return a byte array containing the PIPRequest encoded as a byte array.	 */	public byte[] encodeAsBytes() {		byte[] rlbytes = null;		if (requestLine != null) {			try {				rlbytes = requestLine.encode().getBytes("UTF-8");			} catch (UnsupportedEncodingException ex) {				InternalErrorHandler.handleException(ex);			}		}		byte[] superbytes = super.encodeAsBytes();		byte[] retval = new byte[rlbytes.length + superbytes.length];		int i = 0;		System.arraycopy(rlbytes, 0, retval, 0, rlbytes.length);		System.arraycopy(superbytes, 0, retval, rlbytes.length,				superbytes.length);		return retval;	}	/**	 * Creates a default PIPResponse message for this request. Note You must add	 * the necessary tags to outgoing responses if need be. For efficiency, this	 * method does not clone the incoming request. If you want to modify the	 * outgoing response, be sure to clone the incoming request as the headers	 * are shared and any modification to the headers of the outgoing response	 * will result in a modification of the incoming request. Tag fields are	 * just copied from the incoming request. ContactHeader headers are removed from	 * the incoming request. Added by Jeff Keyser.	 * 	 * @param statusCode	 *            Status code for the response. Reason phrase is generated.	 * 	 * @return A PIPResponse with the status and reason supplied, and a copy of	 *         all the original headers from this request.	 */	public PIPResponse createResponse(int statusCode) {				String reasonPhrase = PIPResponse.getReasonPhrase(statusCode);		return this.createResponse(statusCode, reasonPhrase);	}	/**	 * Creates a default PIPResponse message for this request. Note You must add	 * the necessary tags to outgoing responses if need be. For efficiency, this	 * method does not clone the incoming request. If you want to modify the	 * outgoing response, be sure to clone the incoming request as the headers	 * are shared and any modification to the headers of the outgoing response	 * will result in a modification of the incoming request. Tag fields are	 * just copied from the incoming request. ContactHeader headers are removed from	 * the incoming request. Added by Jeff Keyser. Route headers are not added	 * to the response.	 * 	 * @param statusCode	 *            Status code for the response.	 * @param reasonPhrase	 *            Reason phrase for this response.	 * 	 * @return A PIPResponse with the status and reason supplied, and a copy of	 *         all the original headers from this request except the ones that	 *         are not supposed to be part of the response .	 */	public PIPResponse createResponse(int statusCode, String reasonPhrase) {		PIPResponse newResponse;		Iterator headerIterator;		PIPHeader nextHeader;		newResponse = new PIPResponse();		try {			newResponse.setStatusCode(statusCode);		} catch (ParseException ex) {			throw new IllegalArgumentException("Bad code " + statusCode);		}		if (reasonPhrase != null)			newResponse.setReasonPhrase(reasonPhrase);		else			newResponse					.setReasonPhrase(PIPResponse.getReasonPhrase(statusCode));		headerIterator = getHeaders();		while (headerIterator.hasNext()) {			nextHeader = (PIPHeader) headerIterator.next();			if (nextHeader instanceof FromHeader					|| nextHeader instanceof ToHeader					|| nextHeader instanceof CallIdHeader					|| (statusCode / 100 <= 2 && statusCode / 100 > 1)					// No record routing for error and 100					|| nextHeader instanceof CSeqHeader) {				try {										newResponse.attachHeader((PIPHeader) nextHeader.clone(),							false);				} catch (PIPDuplicateHeaderException e) {					e.printStackTrace();				}			}		}		if (newResponse.getStatusCode() == 100) {			// Trying is never supposed to have the tag parameter set.			newResponse.getTo().removeParameter("tag");		}		return newResponse;	}	/**	 * Creates a default PIPResquest message that would cancel this request.	 * Note that tag assignment and removal of is left to the caller (we use	 * whatever tags are present in the original request).	 * 	 * @return A CANCEL PIPRequest with a copy all the original headers from	 *         this request except for Require, ProxyRequire.	 */	public PIPRequest createCancelRequest() {		PIPRequest newRequest;		Iterator headerIterator;		PIPHeader nextHeader;		newRequest = new PIPRequest();		newRequest.setRequestLine((RequestLine) this.requestLine.clone());		newRequest.setMethod(PIPRequest.CANCEL);		headerIterator = getHeaders();		while (headerIterator.hasNext()) {			nextHeader = (PIPHeader) headerIterator.next();			/*			 * RFC 3261 9.1 (Client Behavior) The CANCEL request MUST NOT			 * contain any Require or Proxy-Require header fields.			 */			if (nextHeader instanceof ContentLengthHeader)				continue;			else if (nextHeader instanceof ContentTypeHeader)				continue;			// ContactHeader header shold not be present in ACK or cancel.			else if (nextHeader instanceof ContactList)				continue;			// CSeqHeader method for a cancel request must be cancel.			if (nextHeader instanceof CSeqHeader) {				CSeqHeader cseq = (CSeqHeader) nextHeader.clone();				try {					cseq.setMethod(PIPRequest.CANCEL);				} catch (ParseException e) {					InternalErrorHandler.handleException(e);				}				nextHeader = cseq;			} else {				nextHeader = (PIPHeader) nextHeader.clone();			}			try {				newRequest.attachHeader(nextHeader, false);			} catch (PIPDuplicateHeaderException e) {				e.printStackTrace();				InternalErrorHandler.handleException(e);			}		}		return newRequest;	}	/**	 * Creates a default ACK PIPRequest message for this original request. Note	 * that the defaultACK PIPRequest does not include the content of the	 * original PIPRequest. If responseToHeader is null then the toHeader of	 * this request is used to construct the ACK. Note that tag fields are just	 * copied from the original PIP Request. Added by Jeff Keyser.	 * 	 * @param responseToHeader	 *            ToHeader header to use for this request.	 * 	 * @return A PIPRequest with an ACK method.	 */	public PIPRequest createAckRequest(ToHeader responseToHeader) {		PIPRequest newRequest;		Iterator headerIterator;		PIPHeader nextHeader;		newRequest = new PIPRequest();		newRequest.setRequestLine((RequestLine) this.requestLine.clone());		newRequest.setMethod(PIPRequest.ACK);		headerIterator = getHeaders();		while (headerIterator.hasNext()) {			nextHeader = (PIPHeader) headerIterator.next();			if (nextHeader instanceof ContentLengthHeader) {				// Adding content is responsibility of user.				nextHeader = (PIPHeader) nextHeader.clone();				try {					((ContentLengthHeader) nextHeader).setContentLength(0);				} catch (InvalidArgumentException e) {				}			} else if (nextHeader instanceof ContentTypeHeader) {				// Content type header is removed since				// content length is 0.				continue;			} else if (nextHeader instanceof CSeqHeader) {				// The CSeqHeader header field in the				// ACK MUST contain the same value for the				// sequence number as was present in the				// original request, but the method parameter				// MUST be equal to "ACK".				CSeqHeader cseq = (CSeqHeader) nextHeader.clone();				try {					cseq.setMethod(PIPRequest.ACK);				} catch (ParseException e) {				}				nextHeader = cseq;			} else if (nextHeader instanceof ToHeader) {				if (responseToHeader != null) {					nextHeader = responseToHeader;				} else {					nextHeader = (PIPHeader) nextHeader.clone();				}			} else if (nextHeader instanceof ContactList) {				// CONTACT header does not apply for ACK requests.				continue;			} else {				nextHeader = (PIPHeader) nextHeader.clone();			}			try {				newRequest.attachHeader(nextHeader, false);			} catch (PIPDuplicateHeaderException e) {				e.printStackTrace();			}		}		return newRequest;	}	/**	 * Create a new default PIPRequest from the original request. Warning: the	 * newly created PIPRequest, shares the headers of this request but we	 * generate any new headers that we need to modify so the original request	 * is umodified. However, if you modify the shared headers after this	 * request is created, then the newly created request will also be modified.	 * If you want to modify the original request without affecting the returned	 * Request make sure you clone it before calling this method.	 * 	 * Only required headers are copied.	 * <ul>	 * <li> ContactHeader headers are not included in the newly created request.	 * Setting the appropriate sequence number is the responsibility of the	 * caller. </li>	 * <li> RouteList is not copied for ACK and CANCEL </li>	 * <li> Note that we DO NOT copy the body of the argument into the returned	 * header. We do not copy the content type header from the original request	 * either. These have to be added seperately and the content length has to	 * be correctly set if necessary the content length is set to 0 in the	 * returned header. </li>	 * <li>ContactHeader List is not copied from the original request.</li>	 * <li>RecordRoute List is not included from original request. </li>	 * <li>Via header is not included from the original request. </li>	 * </ul>	 * 	 * @param requestLine	 *            is the new request line.	 * 	 * @param switchHeaders	 *            is a boolean flag that causes to and from headers to switch	 *            (set this to true if you are the server of the transaction and	 *            are generating a BYE request). If the headers are switched, we	 *            generate new FromHeader and ToHeader headers otherwise we just use the	 *            incoming headers.	 * 	 * @return a new Default PIP Request which has the requestLine specified.	 * 	 */	public PIPRequest createPIPRequest(RequestLine requestLine,			boolean switchHeaders) {		PIPRequest newRequest = new PIPRequest();		newRequest.requestLine = requestLine;		Iterator headerIterator = this.getHeaders();		while (headerIterator.hasNext()) {			PIPHeader nextHeader = (PIPHeader) headerIterator.next();			// For BYE and cancel set the CSeqHeader header to the			// appropriate method.			if (nextHeader instanceof CSeqHeader) {				CSeqHeader newCseq = (CSeqHeader) nextHeader.clone();				nextHeader = newCseq;				try {					newCseq.setMethod(requestLine.getMethod());				} catch (ParseException e) {				}			} else if (nextHeader instanceof ToHeader) {				ToHeader to = (ToHeader) nextHeader;				if (switchHeaders) {					nextHeader = new FromHeader(to);				} else {					nextHeader = (PIPHeader) to.clone();					((ToHeader) nextHeader).removeTag();				}			} else if (nextHeader instanceof FromHeader) {				FromHeader from = (FromHeader) nextHeader;				if (switchHeaders) {					nextHeader = new ToHeader(from);					((ToHeader) nextHeader).removeTag();				} else {					nextHeader = (PIPHeader) from.clone();				}			} else if (nextHeader instanceof ContentLengthHeader) {				ContentLengthHeader cl = (ContentLengthHeader) nextHeader.clone();				try {					cl.setContentLength(0);				} catch (InvalidArgumentException e) {				}				nextHeader = cl;			}			try {				newRequest.attachHeader(nextHeader, false);			} catch (PIPDuplicateHeaderException e) {				e.printStackTrace();			}		}		return newRequest;	}	/**	 * Create a BYE request from this request.	 * 	 * @param switchHeaders	 *            is a boolean flag that causes from and isServerTransaction to	 *            headers to be swapped. Set this to true if you are the server	 *            of the dialog and are generating a BYE request for the dialog.	 * @return a new default BYE request.	 */	public PIPRequest createBYERequest(boolean switchHeaders) {		RequestLine requestLine = (RequestLine) this.requestLine.clone();		requestLine.setMethod("BYE");		return this.createPIPRequest(requestLine, switchHeaders);	}	/**	 * Create an ACK request from this request. This is suitable for generating	 * an ACK for an INVITE client transaction.	 * 	 * @return an ACK request that is generated from this request.	 */	public PIPRequest createACKRequest() {		RequestLine requestLine = (RequestLine) this.requestLine.clone();		requestLine.setMethod(PIPRequest.ACK);		return this.createPIPRequest(requestLine, false);	}	/**	 * Get the first line encoded.	 * 	 * @return a string containing the encoded request line.	 */	public String getFirstLine() {		if (requestLine == null)			return null;		else			return this.requestLine.encode();	}	/**	 * Set the pip version.	 * 	 * @param pipVersion	 *            the pip version to set.	 */	public void setPIPVersion(String pipVersion) throws ParseException {		if (pipVersion == null || !pipVersion.equalsIgnoreCase("PIP/1.0"))			throw new ParseException("pipVersion", 0);		this.requestLine.setPIPVersion(pipVersion);	}	/**	 * Get the PIP version.	 * 	 * @return the PIP version from the request line.	 */	public String getPIPVersion() {		return this.requestLine.getPipVersion();	}	/**	 * Book keeping method to get the messasge channel for the request.	 * 	 * @return the message channel for the request.	 */	public Object getMessageChannel() {		// return opaque ptr to the message chanel on		// which the message was recieved. For consistency		// checking and lookup.		return this.messageChannel;	}	/**	 * Set the message channel for the request ( bookkeeping field ).	 * 	 * @param messageChannel	 */	public void setMessageChannel(Object messageChannel) {		this.messageChannel = messageChannel;	}	}